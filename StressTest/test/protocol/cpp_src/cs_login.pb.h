// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: cs_login.proto

#ifndef PROTOBUF_cs_5flogin_2eproto__INCLUDED
#define PROTOBUF_cs_5flogin_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
#include "cs_common.pb.h"
#include "cs_enum.pb.h"
// @@protoc_insertion_point(includes)

namespace cs {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_cs_5flogin_2eproto();
void protobuf_AssignDesc_cs_5flogin_2eproto();
void protobuf_ShutdownFile_cs_5flogin_2eproto();

class DeviceDataType;
class CSLoginReq;
class CSLoginRes;
class CSReloginReq;
class CSReloginRes;
class CSFinalizeaccountReq;
class CSFinalizeaccountRes;
class CSGetRandomNameReq;
class CSGetRandomNameRes;
class CSChangeNameReq;
class CSChangeNameRes;

// ===================================================================

class DeviceDataType : public ::google::protobuf::Message {
 public:
  DeviceDataType();
  virtual ~DeviceDataType();

  DeviceDataType(const DeviceDataType& from);

  inline DeviceDataType& operator=(const DeviceDataType& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DeviceDataType& default_instance();

  void Swap(DeviceDataType* other);

  // implements Message ----------------------------------------------

  DeviceDataType* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DeviceDataType& from);
  void MergeFrom(const DeviceDataType& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string Device = 1;
  inline bool has_device() const;
  inline void clear_device();
  static const int kDeviceFieldNumber = 1;
  inline const ::std::string& device() const;
  inline void set_device(const ::std::string& value);
  inline void set_device(const char* value);
  inline void set_device(const char* value, size_t size);
  inline ::std::string* mutable_device();
  inline ::std::string* release_device();
  inline void set_allocated_device(::std::string* device);

  // optional string SessionDevice = 2;
  inline bool has_sessiondevice() const;
  inline void clear_sessiondevice();
  static const int kSessionDeviceFieldNumber = 2;
  inline const ::std::string& sessiondevice() const;
  inline void set_sessiondevice(const ::std::string& value);
  inline void set_sessiondevice(const char* value);
  inline void set_sessiondevice(const char* value, size_t size);
  inline ::std::string* mutable_sessiondevice();
  inline ::std::string* release_sessiondevice();
  inline void set_allocated_sessiondevice(::std::string* sessiondevice);

  // optional string IMEI = 3;
  inline bool has_imei() const;
  inline void clear_imei();
  static const int kIMEIFieldNumber = 3;
  inline const ::std::string& imei() const;
  inline void set_imei(const ::std::string& value);
  inline void set_imei(const char* value);
  inline void set_imei(const char* value, size_t size);
  inline ::std::string* mutable_imei();
  inline ::std::string* release_imei();
  inline void set_allocated_imei(::std::string* imei);

  // optional string NTYPE = 4;
  inline bool has_ntype() const;
  inline void clear_ntype();
  static const int kNTYPEFieldNumber = 4;
  inline const ::std::string& ntype() const;
  inline void set_ntype(const ::std::string& value);
  inline void set_ntype(const char* value);
  inline void set_ntype(const char* value, size_t size);
  inline ::std::string* mutable_ntype();
  inline ::std::string* release_ntype();
  inline void set_allocated_ntype(::std::string* ntype);

  // optional string OS = 5;
  inline bool has_os() const;
  inline void clear_os();
  static const int kOSFieldNumber = 5;
  inline const ::std::string& os() const;
  inline void set_os(const ::std::string& value);
  inline void set_os(const char* value);
  inline void set_os(const char* value, size_t size);
  inline ::std::string* mutable_os();
  inline ::std::string* release_os();
  inline void set_allocated_os(::std::string* os);

  // optional int32 MemSize = 6;
  inline bool has_memsize() const;
  inline void clear_memsize();
  static const int kMemSizeFieldNumber = 6;
  inline ::google::protobuf::int32 memsize() const;
  inline void set_memsize(::google::protobuf::int32 value);

  // optional string DISP = 7;
  inline bool has_disp() const;
  inline void clear_disp();
  static const int kDISPFieldNumber = 7;
  inline const ::std::string& disp() const;
  inline void set_disp(const ::std::string& value);
  inline void set_disp(const char* value);
  inline void set_disp(const char* value, size_t size);
  inline ::std::string* mutable_disp();
  inline ::std::string* release_disp();
  inline void set_allocated_disp(::std::string* disp);

  // optional string MAC = 8;
  inline bool has_mac() const;
  inline void clear_mac();
  static const int kMACFieldNumber = 8;
  inline const ::std::string& mac() const;
  inline void set_mac(const ::std::string& value);
  inline void set_mac(const char* value);
  inline void set_mac(const char* value, size_t size);
  inline ::std::string* mutable_mac();
  inline ::std::string* release_mac();
  inline void set_allocated_mac(::std::string* mac);

  // optional .cs.NetWorkSP NetSP = 9 [default = TELECOM];
  inline bool has_netsp() const;
  inline void clear_netsp();
  static const int kNetSPFieldNumber = 9;
  inline ::cs::NetWorkSP netsp() const;
  inline void set_netsp(::cs::NetWorkSP value);

  // @@protoc_insertion_point(class_scope:cs.DeviceDataType)
 private:
  inline void set_has_device();
  inline void clear_has_device();
  inline void set_has_sessiondevice();
  inline void clear_has_sessiondevice();
  inline void set_has_imei();
  inline void clear_has_imei();
  inline void set_has_ntype();
  inline void clear_has_ntype();
  inline void set_has_os();
  inline void clear_has_os();
  inline void set_has_memsize();
  inline void clear_has_memsize();
  inline void set_has_disp();
  inline void clear_has_disp();
  inline void set_has_mac();
  inline void clear_has_mac();
  inline void set_has_netsp();
  inline void clear_has_netsp();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* device_;
  ::std::string* sessiondevice_;
  ::std::string* imei_;
  ::std::string* ntype_;
  ::std::string* os_;
  ::std::string* disp_;
  ::google::protobuf::int32 memsize_;
  int netsp_;
  ::std::string* mac_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];

  friend void  protobuf_AddDesc_cs_5flogin_2eproto();
  friend void protobuf_AssignDesc_cs_5flogin_2eproto();
  friend void protobuf_ShutdownFile_cs_5flogin_2eproto();

  void InitAsDefaultInstance();
  static DeviceDataType* default_instance_;
};
// -------------------------------------------------------------------

class CSLoginReq : public ::google::protobuf::Message {
 public:
  CSLoginReq();
  virtual ~CSLoginReq();

  CSLoginReq(const CSLoginReq& from);

  inline CSLoginReq& operator=(const CSLoginReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CSLoginReq& default_instance();

  void Swap(CSLoginReq* other);

  // implements Message ----------------------------------------------

  CSLoginReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CSLoginReq& from);
  void MergeFrom(const CSLoginReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string PlayerAccount = 1;
  inline bool has_playeraccount() const;
  inline void clear_playeraccount();
  static const int kPlayerAccountFieldNumber = 1;
  inline const ::std::string& playeraccount() const;
  inline void set_playeraccount(const ::std::string& value);
  inline void set_playeraccount(const char* value);
  inline void set_playeraccount(const char* value, size_t size);
  inline ::std::string* mutable_playeraccount();
  inline ::std::string* release_playeraccount();
  inline void set_allocated_playeraccount(::std::string* playeraccount);

  // required string Token = 2;
  inline bool has_token() const;
  inline void clear_token();
  static const int kTokenFieldNumber = 2;
  inline const ::std::string& token() const;
  inline void set_token(const ::std::string& value);
  inline void set_token(const char* value);
  inline void set_token(const char* value, size_t size);
  inline ::std::string* mutable_token();
  inline ::std::string* release_token();
  inline void set_allocated_token(::std::string* token);

  // required .cs.VersionResourceType VersionResource = 3;
  inline bool has_versionresource() const;
  inline void clear_versionresource();
  static const int kVersionResourceFieldNumber = 3;
  inline const ::cs::VersionResourceType& versionresource() const;
  inline ::cs::VersionResourceType* mutable_versionresource();
  inline ::cs::VersionResourceType* release_versionresource();
  inline void set_allocated_versionresource(::cs::VersionResourceType* versionresource);

  // optional string PlatType = 4;
  inline bool has_plattype() const;
  inline void clear_plattype();
  static const int kPlatTypeFieldNumber = 4;
  inline const ::std::string& plattype() const;
  inline void set_plattype(const ::std::string& value);
  inline void set_plattype(const char* value);
  inline void set_plattype(const char* value, size_t size);
  inline ::std::string* mutable_plattype();
  inline ::std::string* release_plattype();
  inline void set_allocated_plattype(::std::string* plattype);

  // optional .cs.DeviceDataType DeviceData = 5;
  inline bool has_devicedata() const;
  inline void clear_devicedata();
  static const int kDeviceDataFieldNumber = 5;
  inline const ::cs::DeviceDataType& devicedata() const;
  inline ::cs::DeviceDataType* mutable_devicedata();
  inline ::cs::DeviceDataType* release_devicedata();
  inline void set_allocated_devicedata(::cs::DeviceDataType* devicedata);

  // optional string PlayerPassWd = 6;
  inline bool has_playerpasswd() const;
  inline void clear_playerpasswd();
  static const int kPlayerPassWdFieldNumber = 6;
  inline const ::std::string& playerpasswd() const;
  inline void set_playerpasswd(const ::std::string& value);
  inline void set_playerpasswd(const char* value);
  inline void set_playerpasswd(const char* value, size_t size);
  inline ::std::string* mutable_playerpasswd();
  inline ::std::string* release_playerpasswd();
  inline void set_allocated_playerpasswd(::std::string* playerpasswd);

  // @@protoc_insertion_point(class_scope:cs.CSLoginReq)
 private:
  inline void set_has_playeraccount();
  inline void clear_has_playeraccount();
  inline void set_has_token();
  inline void clear_has_token();
  inline void set_has_versionresource();
  inline void clear_has_versionresource();
  inline void set_has_plattype();
  inline void clear_has_plattype();
  inline void set_has_devicedata();
  inline void clear_has_devicedata();
  inline void set_has_playerpasswd();
  inline void clear_has_playerpasswd();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* playeraccount_;
  ::std::string* token_;
  ::cs::VersionResourceType* versionresource_;
  ::std::string* plattype_;
  ::cs::DeviceDataType* devicedata_;
  ::std::string* playerpasswd_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_cs_5flogin_2eproto();
  friend void protobuf_AssignDesc_cs_5flogin_2eproto();
  friend void protobuf_ShutdownFile_cs_5flogin_2eproto();

  void InitAsDefaultInstance();
  static CSLoginReq* default_instance_;
};
// -------------------------------------------------------------------

class CSLoginRes : public ::google::protobuf::Message {
 public:
  CSLoginRes();
  virtual ~CSLoginRes();

  CSLoginRes(const CSLoginRes& from);

  inline CSLoginRes& operator=(const CSLoginRes& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CSLoginRes& default_instance();

  void Swap(CSLoginRes* other);

  // implements Message ----------------------------------------------

  CSLoginRes* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CSLoginRes& from);
  void MergeFrom(const CSLoginRes& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 ServerTime = 1;
  inline bool has_servertime() const;
  inline void clear_servertime();
  static const int kServerTimeFieldNumber = 1;
  inline ::google::protobuf::int32 servertime() const;
  inline void set_servertime(::google::protobuf::int32 value);

  // optional bool ForceUpdate = 2;
  inline bool has_forceupdate() const;
  inline void clear_forceupdate();
  static const int kForceUpdateFieldNumber = 2;
  inline bool forceupdate() const;
  inline void set_forceupdate(bool value);

  // optional string DownLoadUrl = 3;
  inline bool has_downloadurl() const;
  inline void clear_downloadurl();
  static const int kDownLoadUrlFieldNumber = 3;
  inline const ::std::string& downloadurl() const;
  inline void set_downloadurl(const ::std::string& value);
  inline void set_downloadurl(const char* value);
  inline void set_downloadurl(const char* value, size_t size);
  inline ::std::string* mutable_downloadurl();
  inline ::std::string* release_downloadurl();
  inline void set_allocated_downloadurl(::std::string* downloadurl);

  // optional int32 PlayerId = 4;
  inline bool has_playerid() const;
  inline void clear_playerid();
  static const int kPlayerIdFieldNumber = 4;
  inline ::google::protobuf::int32 playerid() const;
  inline void set_playerid(::google::protobuf::int32 value);

  // optional string Name = 5;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 5;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional int32 RoleState = 6;
  inline bool has_rolestate() const;
  inline void clear_rolestate();
  static const int kRoleStateFieldNumber = 6;
  inline ::google::protobuf::int32 rolestate() const;
  inline void set_rolestate(::google::protobuf::int32 value);

  // optional string Hash = 7;
  inline bool has_hash() const;
  inline void clear_hash();
  static const int kHashFieldNumber = 7;
  inline const ::std::string& hash() const;
  inline void set_hash(const ::std::string& value);
  inline void set_hash(const char* value);
  inline void set_hash(const char* value, size_t size);
  inline ::std::string* mutable_hash();
  inline ::std::string* release_hash();
  inline void set_allocated_hash(::std::string* hash);

  // optional bytes SecretKey = 8;
  inline bool has_secretkey() const;
  inline void clear_secretkey();
  static const int kSecretKeyFieldNumber = 8;
  inline const ::std::string& secretkey() const;
  inline void set_secretkey(const ::std::string& value);
  inline void set_secretkey(const char* value);
  inline void set_secretkey(const void* value, size_t size);
  inline ::std::string* mutable_secretkey();
  inline ::std::string* release_secretkey();
  inline void set_allocated_secretkey(::std::string* secretkey);

  // optional bool IsBeAttacking = 9;
  inline bool has_isbeattacking() const;
  inline void clear_isbeattacking();
  static const int kIsBeAttackingFieldNumber = 9;
  inline bool isbeattacking() const;
  inline void set_isbeattacking(bool value);

  // optional uint32 BeAttackingLeftTime = 10;
  inline bool has_beattackinglefttime() const;
  inline void clear_beattackinglefttime();
  static const int kBeAttackingLeftTimeFieldNumber = 10;
  inline ::google::protobuf::uint32 beattackinglefttime() const;
  inline void set_beattackinglefttime(::google::protobuf::uint32 value);

  // optional uint64 Env = 11;
  inline bool has_env() const;
  inline void clear_env();
  static const int kEnvFieldNumber = 11;
  inline ::google::protobuf::uint64 env() const;
  inline void set_env(::google::protobuf::uint64 value);

  // optional string Notify = 12;
  inline bool has_notify() const;
  inline void clear_notify();
  static const int kNotifyFieldNumber = 12;
  inline const ::std::string& notify() const;
  inline void set_notify(const ::std::string& value);
  inline void set_notify(const char* value);
  inline void set_notify(const char* value, size_t size);
  inline ::std::string* mutable_notify();
  inline ::std::string* release_notify();
  inline void set_allocated_notify(::std::string* notify);

  // optional int32 DefenceAeaId = 13;
  inline bool has_defenceaeaid() const;
  inline void clear_defenceaeaid();
  static const int kDefenceAeaIdFieldNumber = 13;
  inline ::google::protobuf::int32 defenceaeaid() const;
  inline void set_defenceaeaid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:cs.CSLoginRes)
 private:
  inline void set_has_servertime();
  inline void clear_has_servertime();
  inline void set_has_forceupdate();
  inline void clear_has_forceupdate();
  inline void set_has_downloadurl();
  inline void clear_has_downloadurl();
  inline void set_has_playerid();
  inline void clear_has_playerid();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_rolestate();
  inline void clear_has_rolestate();
  inline void set_has_hash();
  inline void clear_has_hash();
  inline void set_has_secretkey();
  inline void clear_has_secretkey();
  inline void set_has_isbeattacking();
  inline void clear_has_isbeattacking();
  inline void set_has_beattackinglefttime();
  inline void clear_has_beattackinglefttime();
  inline void set_has_env();
  inline void clear_has_env();
  inline void set_has_notify();
  inline void clear_has_notify();
  inline void set_has_defenceaeaid();
  inline void clear_has_defenceaeaid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 servertime_;
  ::google::protobuf::int32 playerid_;
  ::std::string* downloadurl_;
  ::std::string* name_;
  bool forceupdate_;
  bool isbeattacking_;
  ::google::protobuf::int32 rolestate_;
  ::std::string* hash_;
  ::std::string* secretkey_;
  ::google::protobuf::uint64 env_;
  ::google::protobuf::uint32 beattackinglefttime_;
  ::google::protobuf::int32 defenceaeaid_;
  ::std::string* notify_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(13 + 31) / 32];

  friend void  protobuf_AddDesc_cs_5flogin_2eproto();
  friend void protobuf_AssignDesc_cs_5flogin_2eproto();
  friend void protobuf_ShutdownFile_cs_5flogin_2eproto();

  void InitAsDefaultInstance();
  static CSLoginRes* default_instance_;
};
// -------------------------------------------------------------------

class CSReloginReq : public ::google::protobuf::Message {
 public:
  CSReloginReq();
  virtual ~CSReloginReq();

  CSReloginReq(const CSReloginReq& from);

  inline CSReloginReq& operator=(const CSReloginReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CSReloginReq& default_instance();

  void Swap(CSReloginReq* other);

  // implements Message ----------------------------------------------

  CSReloginReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CSReloginReq& from);
  void MergeFrom(const CSReloginReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string PlayerAccount = 1;
  inline bool has_playeraccount() const;
  inline void clear_playeraccount();
  static const int kPlayerAccountFieldNumber = 1;
  inline const ::std::string& playeraccount() const;
  inline void set_playeraccount(const ::std::string& value);
  inline void set_playeraccount(const char* value);
  inline void set_playeraccount(const char* value, size_t size);
  inline ::std::string* mutable_playeraccount();
  inline ::std::string* release_playeraccount();
  inline void set_allocated_playeraccount(::std::string* playeraccount);

  // required string Token = 2;
  inline bool has_token() const;
  inline void clear_token();
  static const int kTokenFieldNumber = 2;
  inline const ::std::string& token() const;
  inline void set_token(const ::std::string& value);
  inline void set_token(const char* value);
  inline void set_token(const char* value, size_t size);
  inline ::std::string* mutable_token();
  inline ::std::string* release_token();
  inline void set_allocated_token(::std::string* token);

  // required .cs.VersionResourceType VersionResource = 3;
  inline bool has_versionresource() const;
  inline void clear_versionresource();
  static const int kVersionResourceFieldNumber = 3;
  inline const ::cs::VersionResourceType& versionresource() const;
  inline ::cs::VersionResourceType* mutable_versionresource();
  inline ::cs::VersionResourceType* release_versionresource();
  inline void set_allocated_versionresource(::cs::VersionResourceType* versionresource);

  // optional string PlatType = 4;
  inline bool has_plattype() const;
  inline void clear_plattype();
  static const int kPlatTypeFieldNumber = 4;
  inline const ::std::string& plattype() const;
  inline void set_plattype(const ::std::string& value);
  inline void set_plattype(const char* value);
  inline void set_plattype(const char* value, size_t size);
  inline ::std::string* mutable_plattype();
  inline ::std::string* release_plattype();
  inline void set_allocated_plattype(::std::string* plattype);

  // optional .cs.DeviceDataType DeviceData = 5;
  inline bool has_devicedata() const;
  inline void clear_devicedata();
  static const int kDeviceDataFieldNumber = 5;
  inline const ::cs::DeviceDataType& devicedata() const;
  inline ::cs::DeviceDataType* mutable_devicedata();
  inline ::cs::DeviceDataType* release_devicedata();
  inline void set_allocated_devicedata(::cs::DeviceDataType* devicedata);

  // @@protoc_insertion_point(class_scope:cs.CSReloginReq)
 private:
  inline void set_has_playeraccount();
  inline void clear_has_playeraccount();
  inline void set_has_token();
  inline void clear_has_token();
  inline void set_has_versionresource();
  inline void clear_has_versionresource();
  inline void set_has_plattype();
  inline void clear_has_plattype();
  inline void set_has_devicedata();
  inline void clear_has_devicedata();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* playeraccount_;
  ::std::string* token_;
  ::cs::VersionResourceType* versionresource_;
  ::std::string* plattype_;
  ::cs::DeviceDataType* devicedata_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_cs_5flogin_2eproto();
  friend void protobuf_AssignDesc_cs_5flogin_2eproto();
  friend void protobuf_ShutdownFile_cs_5flogin_2eproto();

  void InitAsDefaultInstance();
  static CSReloginReq* default_instance_;
};
// -------------------------------------------------------------------

class CSReloginRes : public ::google::protobuf::Message {
 public:
  CSReloginRes();
  virtual ~CSReloginRes();

  CSReloginRes(const CSReloginRes& from);

  inline CSReloginRes& operator=(const CSReloginRes& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CSReloginRes& default_instance();

  void Swap(CSReloginRes* other);

  // implements Message ----------------------------------------------

  CSReloginRes* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CSReloginRes& from);
  void MergeFrom(const CSReloginRes& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 ServerTime = 1;
  inline bool has_servertime() const;
  inline void clear_servertime();
  static const int kServerTimeFieldNumber = 1;
  inline ::google::protobuf::int32 servertime() const;
  inline void set_servertime(::google::protobuf::int32 value);

  // optional bool ForceUpdate = 2;
  inline bool has_forceupdate() const;
  inline void clear_forceupdate();
  static const int kForceUpdateFieldNumber = 2;
  inline bool forceupdate() const;
  inline void set_forceupdate(bool value);

  // optional string DownLoadUrl = 3;
  inline bool has_downloadurl() const;
  inline void clear_downloadurl();
  static const int kDownLoadUrlFieldNumber = 3;
  inline const ::std::string& downloadurl() const;
  inline void set_downloadurl(const ::std::string& value);
  inline void set_downloadurl(const char* value);
  inline void set_downloadurl(const char* value, size_t size);
  inline ::std::string* mutable_downloadurl();
  inline ::std::string* release_downloadurl();
  inline void set_allocated_downloadurl(::std::string* downloadurl);

  // optional int32 PlayerId = 4;
  inline bool has_playerid() const;
  inline void clear_playerid();
  static const int kPlayerIdFieldNumber = 4;
  inline ::google::protobuf::int32 playerid() const;
  inline void set_playerid(::google::protobuf::int32 value);

  // optional string Name = 5;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 5;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional int32 RoleState = 6;
  inline bool has_rolestate() const;
  inline void clear_rolestate();
  static const int kRoleStateFieldNumber = 6;
  inline ::google::protobuf::int32 rolestate() const;
  inline void set_rolestate(::google::protobuf::int32 value);

  // optional string Hash = 7;
  inline bool has_hash() const;
  inline void clear_hash();
  static const int kHashFieldNumber = 7;
  inline const ::std::string& hash() const;
  inline void set_hash(const ::std::string& value);
  inline void set_hash(const char* value);
  inline void set_hash(const char* value, size_t size);
  inline ::std::string* mutable_hash();
  inline ::std::string* release_hash();
  inline void set_allocated_hash(::std::string* hash);

  // optional bytes SecretKey = 8;
  inline bool has_secretkey() const;
  inline void clear_secretkey();
  static const int kSecretKeyFieldNumber = 8;
  inline const ::std::string& secretkey() const;
  inline void set_secretkey(const ::std::string& value);
  inline void set_secretkey(const char* value);
  inline void set_secretkey(const void* value, size_t size);
  inline ::std::string* mutable_secretkey();
  inline ::std::string* release_secretkey();
  inline void set_allocated_secretkey(::std::string* secretkey);

  // optional bool IsBeAttacking = 9;
  inline bool has_isbeattacking() const;
  inline void clear_isbeattacking();
  static const int kIsBeAttackingFieldNumber = 9;
  inline bool isbeattacking() const;
  inline void set_isbeattacking(bool value);

  // optional uint32 BeAttackingLeftTime = 10;
  inline bool has_beattackinglefttime() const;
  inline void clear_beattackinglefttime();
  static const int kBeAttackingLeftTimeFieldNumber = 10;
  inline ::google::protobuf::uint32 beattackinglefttime() const;
  inline void set_beattackinglefttime(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:cs.CSReloginRes)
 private:
  inline void set_has_servertime();
  inline void clear_has_servertime();
  inline void set_has_forceupdate();
  inline void clear_has_forceupdate();
  inline void set_has_downloadurl();
  inline void clear_has_downloadurl();
  inline void set_has_playerid();
  inline void clear_has_playerid();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_rolestate();
  inline void clear_has_rolestate();
  inline void set_has_hash();
  inline void clear_has_hash();
  inline void set_has_secretkey();
  inline void clear_has_secretkey();
  inline void set_has_isbeattacking();
  inline void clear_has_isbeattacking();
  inline void set_has_beattackinglefttime();
  inline void clear_has_beattackinglefttime();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 servertime_;
  ::google::protobuf::int32 playerid_;
  ::std::string* downloadurl_;
  ::std::string* name_;
  bool forceupdate_;
  bool isbeattacking_;
  ::google::protobuf::int32 rolestate_;
  ::std::string* hash_;
  ::std::string* secretkey_;
  ::google::protobuf::uint32 beattackinglefttime_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(10 + 31) / 32];

  friend void  protobuf_AddDesc_cs_5flogin_2eproto();
  friend void protobuf_AssignDesc_cs_5flogin_2eproto();
  friend void protobuf_ShutdownFile_cs_5flogin_2eproto();

  void InitAsDefaultInstance();
  static CSReloginRes* default_instance_;
};
// -------------------------------------------------------------------

class CSFinalizeaccountReq : public ::google::protobuf::Message {
 public:
  CSFinalizeaccountReq();
  virtual ~CSFinalizeaccountReq();

  CSFinalizeaccountReq(const CSFinalizeaccountReq& from);

  inline CSFinalizeaccountReq& operator=(const CSFinalizeaccountReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CSFinalizeaccountReq& default_instance();

  void Swap(CSFinalizeaccountReq* other);

  // implements Message ----------------------------------------------

  CSFinalizeaccountReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CSFinalizeaccountReq& from);
  void MergeFrom(const CSFinalizeaccountReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 FinalColor = 1;
  inline bool has_finalcolor() const;
  inline void clear_finalcolor();
  static const int kFinalColorFieldNumber = 1;
  inline ::google::protobuf::int32 finalcolor() const;
  inline void set_finalcolor(::google::protobuf::int32 value);

  // required string FinalName = 2;
  inline bool has_finalname() const;
  inline void clear_finalname();
  static const int kFinalNameFieldNumber = 2;
  inline const ::std::string& finalname() const;
  inline void set_finalname(const ::std::string& value);
  inline void set_finalname(const char* value);
  inline void set_finalname(const char* value, size_t size);
  inline ::std::string* mutable_finalname();
  inline ::std::string* release_finalname();
  inline void set_allocated_finalname(::std::string* finalname);

  // @@protoc_insertion_point(class_scope:cs.CSFinalizeaccountReq)
 private:
  inline void set_has_finalcolor();
  inline void clear_has_finalcolor();
  inline void set_has_finalname();
  inline void clear_has_finalname();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* finalname_;
  ::google::protobuf::int32 finalcolor_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_cs_5flogin_2eproto();
  friend void protobuf_AssignDesc_cs_5flogin_2eproto();
  friend void protobuf_ShutdownFile_cs_5flogin_2eproto();

  void InitAsDefaultInstance();
  static CSFinalizeaccountReq* default_instance_;
};
// -------------------------------------------------------------------

class CSFinalizeaccountRes : public ::google::protobuf::Message {
 public:
  CSFinalizeaccountRes();
  virtual ~CSFinalizeaccountRes();

  CSFinalizeaccountRes(const CSFinalizeaccountRes& from);

  inline CSFinalizeaccountRes& operator=(const CSFinalizeaccountRes& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CSFinalizeaccountRes& default_instance();

  void Swap(CSFinalizeaccountRes* other);

  // implements Message ----------------------------------------------

  CSFinalizeaccountRes* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CSFinalizeaccountRes& from);
  void MergeFrom(const CSFinalizeaccountRes& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string Name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional int32 Status = 2;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 2;
  inline ::google::protobuf::int32 status() const;
  inline void set_status(::google::protobuf::int32 value);

  // optional string Reason = 3;
  inline bool has_reason() const;
  inline void clear_reason();
  static const int kReasonFieldNumber = 3;
  inline const ::std::string& reason() const;
  inline void set_reason(const ::std::string& value);
  inline void set_reason(const char* value);
  inline void set_reason(const char* value, size_t size);
  inline ::std::string* mutable_reason();
  inline ::std::string* release_reason();
  inline void set_allocated_reason(::std::string* reason);

  // @@protoc_insertion_point(class_scope:cs.CSFinalizeaccountRes)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_reason();
  inline void clear_has_reason();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::std::string* reason_;
  ::google::protobuf::int32 status_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_cs_5flogin_2eproto();
  friend void protobuf_AssignDesc_cs_5flogin_2eproto();
  friend void protobuf_ShutdownFile_cs_5flogin_2eproto();

  void InitAsDefaultInstance();
  static CSFinalizeaccountRes* default_instance_;
};
// -------------------------------------------------------------------

class CSGetRandomNameReq : public ::google::protobuf::Message {
 public:
  CSGetRandomNameReq();
  virtual ~CSGetRandomNameReq();

  CSGetRandomNameReq(const CSGetRandomNameReq& from);

  inline CSGetRandomNameReq& operator=(const CSGetRandomNameReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CSGetRandomNameReq& default_instance();

  void Swap(CSGetRandomNameReq* other);

  // implements Message ----------------------------------------------

  CSGetRandomNameReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CSGetRandomNameReq& from);
  void MergeFrom(const CSGetRandomNameReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:cs.CSGetRandomNameReq)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_cs_5flogin_2eproto();
  friend void protobuf_AssignDesc_cs_5flogin_2eproto();
  friend void protobuf_ShutdownFile_cs_5flogin_2eproto();

  void InitAsDefaultInstance();
  static CSGetRandomNameReq* default_instance_;
};
// -------------------------------------------------------------------

class CSGetRandomNameRes : public ::google::protobuf::Message {
 public:
  CSGetRandomNameRes();
  virtual ~CSGetRandomNameRes();

  CSGetRandomNameRes(const CSGetRandomNameRes& from);

  inline CSGetRandomNameRes& operator=(const CSGetRandomNameRes& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CSGetRandomNameRes& default_instance();

  void Swap(CSGetRandomNameRes* other);

  // implements Message ----------------------------------------------

  CSGetRandomNameRes* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CSGetRandomNameRes& from);
  void MergeFrom(const CSGetRandomNameRes& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string Name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // @@protoc_insertion_point(class_scope:cs.CSGetRandomNameRes)
 private:
  inline void set_has_name();
  inline void clear_has_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_cs_5flogin_2eproto();
  friend void protobuf_AssignDesc_cs_5flogin_2eproto();
  friend void protobuf_ShutdownFile_cs_5flogin_2eproto();

  void InitAsDefaultInstance();
  static CSGetRandomNameRes* default_instance_;
};
// -------------------------------------------------------------------

class CSChangeNameReq : public ::google::protobuf::Message {
 public:
  CSChangeNameReq();
  virtual ~CSChangeNameReq();

  CSChangeNameReq(const CSChangeNameReq& from);

  inline CSChangeNameReq& operator=(const CSChangeNameReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CSChangeNameReq& default_instance();

  void Swap(CSChangeNameReq* other);

  // implements Message ----------------------------------------------

  CSChangeNameReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CSChangeNameReq& from);
  void MergeFrom(const CSChangeNameReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string NewName = 1;
  inline bool has_newname() const;
  inline void clear_newname();
  static const int kNewNameFieldNumber = 1;
  inline const ::std::string& newname() const;
  inline void set_newname(const ::std::string& value);
  inline void set_newname(const char* value);
  inline void set_newname(const char* value, size_t size);
  inline ::std::string* mutable_newname();
  inline ::std::string* release_newname();
  inline void set_allocated_newname(::std::string* newname);

  // @@protoc_insertion_point(class_scope:cs.CSChangeNameReq)
 private:
  inline void set_has_newname();
  inline void clear_has_newname();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* newname_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_cs_5flogin_2eproto();
  friend void protobuf_AssignDesc_cs_5flogin_2eproto();
  friend void protobuf_ShutdownFile_cs_5flogin_2eproto();

  void InitAsDefaultInstance();
  static CSChangeNameReq* default_instance_;
};
// -------------------------------------------------------------------

class CSChangeNameRes : public ::google::protobuf::Message {
 public:
  CSChangeNameRes();
  virtual ~CSChangeNameRes();

  CSChangeNameRes(const CSChangeNameRes& from);

  inline CSChangeNameRes& operator=(const CSChangeNameRes& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CSChangeNameRes& default_instance();

  void Swap(CSChangeNameRes* other);

  // implements Message ----------------------------------------------

  CSChangeNameRes* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CSChangeNameRes& from);
  void MergeFrom(const CSChangeNameRes& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:cs.CSChangeNameRes)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_cs_5flogin_2eproto();
  friend void protobuf_AssignDesc_cs_5flogin_2eproto();
  friend void protobuf_ShutdownFile_cs_5flogin_2eproto();

  void InitAsDefaultInstance();
  static CSChangeNameRes* default_instance_;
};
// ===================================================================


// ===================================================================

// DeviceDataType

// optional string Device = 1;
inline bool DeviceDataType::has_device() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DeviceDataType::set_has_device() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DeviceDataType::clear_has_device() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DeviceDataType::clear_device() {
  if (device_ != &::google::protobuf::internal::kEmptyString) {
    device_->clear();
  }
  clear_has_device();
}
inline const ::std::string& DeviceDataType::device() const {
  return *device_;
}
inline void DeviceDataType::set_device(const ::std::string& value) {
  set_has_device();
  if (device_ == &::google::protobuf::internal::kEmptyString) {
    device_ = new ::std::string;
  }
  device_->assign(value);
}
inline void DeviceDataType::set_device(const char* value) {
  set_has_device();
  if (device_ == &::google::protobuf::internal::kEmptyString) {
    device_ = new ::std::string;
  }
  device_->assign(value);
}
inline void DeviceDataType::set_device(const char* value, size_t size) {
  set_has_device();
  if (device_ == &::google::protobuf::internal::kEmptyString) {
    device_ = new ::std::string;
  }
  device_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DeviceDataType::mutable_device() {
  set_has_device();
  if (device_ == &::google::protobuf::internal::kEmptyString) {
    device_ = new ::std::string;
  }
  return device_;
}
inline ::std::string* DeviceDataType::release_device() {
  clear_has_device();
  if (device_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = device_;
    device_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DeviceDataType::set_allocated_device(::std::string* device) {
  if (device_ != &::google::protobuf::internal::kEmptyString) {
    delete device_;
  }
  if (device) {
    set_has_device();
    device_ = device;
  } else {
    clear_has_device();
    device_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string SessionDevice = 2;
inline bool DeviceDataType::has_sessiondevice() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DeviceDataType::set_has_sessiondevice() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DeviceDataType::clear_has_sessiondevice() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DeviceDataType::clear_sessiondevice() {
  if (sessiondevice_ != &::google::protobuf::internal::kEmptyString) {
    sessiondevice_->clear();
  }
  clear_has_sessiondevice();
}
inline const ::std::string& DeviceDataType::sessiondevice() const {
  return *sessiondevice_;
}
inline void DeviceDataType::set_sessiondevice(const ::std::string& value) {
  set_has_sessiondevice();
  if (sessiondevice_ == &::google::protobuf::internal::kEmptyString) {
    sessiondevice_ = new ::std::string;
  }
  sessiondevice_->assign(value);
}
inline void DeviceDataType::set_sessiondevice(const char* value) {
  set_has_sessiondevice();
  if (sessiondevice_ == &::google::protobuf::internal::kEmptyString) {
    sessiondevice_ = new ::std::string;
  }
  sessiondevice_->assign(value);
}
inline void DeviceDataType::set_sessiondevice(const char* value, size_t size) {
  set_has_sessiondevice();
  if (sessiondevice_ == &::google::protobuf::internal::kEmptyString) {
    sessiondevice_ = new ::std::string;
  }
  sessiondevice_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DeviceDataType::mutable_sessiondevice() {
  set_has_sessiondevice();
  if (sessiondevice_ == &::google::protobuf::internal::kEmptyString) {
    sessiondevice_ = new ::std::string;
  }
  return sessiondevice_;
}
inline ::std::string* DeviceDataType::release_sessiondevice() {
  clear_has_sessiondevice();
  if (sessiondevice_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sessiondevice_;
    sessiondevice_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DeviceDataType::set_allocated_sessiondevice(::std::string* sessiondevice) {
  if (sessiondevice_ != &::google::protobuf::internal::kEmptyString) {
    delete sessiondevice_;
  }
  if (sessiondevice) {
    set_has_sessiondevice();
    sessiondevice_ = sessiondevice;
  } else {
    clear_has_sessiondevice();
    sessiondevice_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string IMEI = 3;
inline bool DeviceDataType::has_imei() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DeviceDataType::set_has_imei() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DeviceDataType::clear_has_imei() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DeviceDataType::clear_imei() {
  if (imei_ != &::google::protobuf::internal::kEmptyString) {
    imei_->clear();
  }
  clear_has_imei();
}
inline const ::std::string& DeviceDataType::imei() const {
  return *imei_;
}
inline void DeviceDataType::set_imei(const ::std::string& value) {
  set_has_imei();
  if (imei_ == &::google::protobuf::internal::kEmptyString) {
    imei_ = new ::std::string;
  }
  imei_->assign(value);
}
inline void DeviceDataType::set_imei(const char* value) {
  set_has_imei();
  if (imei_ == &::google::protobuf::internal::kEmptyString) {
    imei_ = new ::std::string;
  }
  imei_->assign(value);
}
inline void DeviceDataType::set_imei(const char* value, size_t size) {
  set_has_imei();
  if (imei_ == &::google::protobuf::internal::kEmptyString) {
    imei_ = new ::std::string;
  }
  imei_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DeviceDataType::mutable_imei() {
  set_has_imei();
  if (imei_ == &::google::protobuf::internal::kEmptyString) {
    imei_ = new ::std::string;
  }
  return imei_;
}
inline ::std::string* DeviceDataType::release_imei() {
  clear_has_imei();
  if (imei_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = imei_;
    imei_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DeviceDataType::set_allocated_imei(::std::string* imei) {
  if (imei_ != &::google::protobuf::internal::kEmptyString) {
    delete imei_;
  }
  if (imei) {
    set_has_imei();
    imei_ = imei;
  } else {
    clear_has_imei();
    imei_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string NTYPE = 4;
inline bool DeviceDataType::has_ntype() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DeviceDataType::set_has_ntype() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DeviceDataType::clear_has_ntype() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DeviceDataType::clear_ntype() {
  if (ntype_ != &::google::protobuf::internal::kEmptyString) {
    ntype_->clear();
  }
  clear_has_ntype();
}
inline const ::std::string& DeviceDataType::ntype() const {
  return *ntype_;
}
inline void DeviceDataType::set_ntype(const ::std::string& value) {
  set_has_ntype();
  if (ntype_ == &::google::protobuf::internal::kEmptyString) {
    ntype_ = new ::std::string;
  }
  ntype_->assign(value);
}
inline void DeviceDataType::set_ntype(const char* value) {
  set_has_ntype();
  if (ntype_ == &::google::protobuf::internal::kEmptyString) {
    ntype_ = new ::std::string;
  }
  ntype_->assign(value);
}
inline void DeviceDataType::set_ntype(const char* value, size_t size) {
  set_has_ntype();
  if (ntype_ == &::google::protobuf::internal::kEmptyString) {
    ntype_ = new ::std::string;
  }
  ntype_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DeviceDataType::mutable_ntype() {
  set_has_ntype();
  if (ntype_ == &::google::protobuf::internal::kEmptyString) {
    ntype_ = new ::std::string;
  }
  return ntype_;
}
inline ::std::string* DeviceDataType::release_ntype() {
  clear_has_ntype();
  if (ntype_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ntype_;
    ntype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DeviceDataType::set_allocated_ntype(::std::string* ntype) {
  if (ntype_ != &::google::protobuf::internal::kEmptyString) {
    delete ntype_;
  }
  if (ntype) {
    set_has_ntype();
    ntype_ = ntype;
  } else {
    clear_has_ntype();
    ntype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string OS = 5;
inline bool DeviceDataType::has_os() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void DeviceDataType::set_has_os() {
  _has_bits_[0] |= 0x00000010u;
}
inline void DeviceDataType::clear_has_os() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void DeviceDataType::clear_os() {
  if (os_ != &::google::protobuf::internal::kEmptyString) {
    os_->clear();
  }
  clear_has_os();
}
inline const ::std::string& DeviceDataType::os() const {
  return *os_;
}
inline void DeviceDataType::set_os(const ::std::string& value) {
  set_has_os();
  if (os_ == &::google::protobuf::internal::kEmptyString) {
    os_ = new ::std::string;
  }
  os_->assign(value);
}
inline void DeviceDataType::set_os(const char* value) {
  set_has_os();
  if (os_ == &::google::protobuf::internal::kEmptyString) {
    os_ = new ::std::string;
  }
  os_->assign(value);
}
inline void DeviceDataType::set_os(const char* value, size_t size) {
  set_has_os();
  if (os_ == &::google::protobuf::internal::kEmptyString) {
    os_ = new ::std::string;
  }
  os_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DeviceDataType::mutable_os() {
  set_has_os();
  if (os_ == &::google::protobuf::internal::kEmptyString) {
    os_ = new ::std::string;
  }
  return os_;
}
inline ::std::string* DeviceDataType::release_os() {
  clear_has_os();
  if (os_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = os_;
    os_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DeviceDataType::set_allocated_os(::std::string* os) {
  if (os_ != &::google::protobuf::internal::kEmptyString) {
    delete os_;
  }
  if (os) {
    set_has_os();
    os_ = os;
  } else {
    clear_has_os();
    os_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 MemSize = 6;
inline bool DeviceDataType::has_memsize() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void DeviceDataType::set_has_memsize() {
  _has_bits_[0] |= 0x00000020u;
}
inline void DeviceDataType::clear_has_memsize() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void DeviceDataType::clear_memsize() {
  memsize_ = 0;
  clear_has_memsize();
}
inline ::google::protobuf::int32 DeviceDataType::memsize() const {
  return memsize_;
}
inline void DeviceDataType::set_memsize(::google::protobuf::int32 value) {
  set_has_memsize();
  memsize_ = value;
}

// optional string DISP = 7;
inline bool DeviceDataType::has_disp() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void DeviceDataType::set_has_disp() {
  _has_bits_[0] |= 0x00000040u;
}
inline void DeviceDataType::clear_has_disp() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void DeviceDataType::clear_disp() {
  if (disp_ != &::google::protobuf::internal::kEmptyString) {
    disp_->clear();
  }
  clear_has_disp();
}
inline const ::std::string& DeviceDataType::disp() const {
  return *disp_;
}
inline void DeviceDataType::set_disp(const ::std::string& value) {
  set_has_disp();
  if (disp_ == &::google::protobuf::internal::kEmptyString) {
    disp_ = new ::std::string;
  }
  disp_->assign(value);
}
inline void DeviceDataType::set_disp(const char* value) {
  set_has_disp();
  if (disp_ == &::google::protobuf::internal::kEmptyString) {
    disp_ = new ::std::string;
  }
  disp_->assign(value);
}
inline void DeviceDataType::set_disp(const char* value, size_t size) {
  set_has_disp();
  if (disp_ == &::google::protobuf::internal::kEmptyString) {
    disp_ = new ::std::string;
  }
  disp_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DeviceDataType::mutable_disp() {
  set_has_disp();
  if (disp_ == &::google::protobuf::internal::kEmptyString) {
    disp_ = new ::std::string;
  }
  return disp_;
}
inline ::std::string* DeviceDataType::release_disp() {
  clear_has_disp();
  if (disp_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = disp_;
    disp_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DeviceDataType::set_allocated_disp(::std::string* disp) {
  if (disp_ != &::google::protobuf::internal::kEmptyString) {
    delete disp_;
  }
  if (disp) {
    set_has_disp();
    disp_ = disp;
  } else {
    clear_has_disp();
    disp_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string MAC = 8;
inline bool DeviceDataType::has_mac() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void DeviceDataType::set_has_mac() {
  _has_bits_[0] |= 0x00000080u;
}
inline void DeviceDataType::clear_has_mac() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void DeviceDataType::clear_mac() {
  if (mac_ != &::google::protobuf::internal::kEmptyString) {
    mac_->clear();
  }
  clear_has_mac();
}
inline const ::std::string& DeviceDataType::mac() const {
  return *mac_;
}
inline void DeviceDataType::set_mac(const ::std::string& value) {
  set_has_mac();
  if (mac_ == &::google::protobuf::internal::kEmptyString) {
    mac_ = new ::std::string;
  }
  mac_->assign(value);
}
inline void DeviceDataType::set_mac(const char* value) {
  set_has_mac();
  if (mac_ == &::google::protobuf::internal::kEmptyString) {
    mac_ = new ::std::string;
  }
  mac_->assign(value);
}
inline void DeviceDataType::set_mac(const char* value, size_t size) {
  set_has_mac();
  if (mac_ == &::google::protobuf::internal::kEmptyString) {
    mac_ = new ::std::string;
  }
  mac_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DeviceDataType::mutable_mac() {
  set_has_mac();
  if (mac_ == &::google::protobuf::internal::kEmptyString) {
    mac_ = new ::std::string;
  }
  return mac_;
}
inline ::std::string* DeviceDataType::release_mac() {
  clear_has_mac();
  if (mac_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = mac_;
    mac_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DeviceDataType::set_allocated_mac(::std::string* mac) {
  if (mac_ != &::google::protobuf::internal::kEmptyString) {
    delete mac_;
  }
  if (mac) {
    set_has_mac();
    mac_ = mac;
  } else {
    clear_has_mac();
    mac_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .cs.NetWorkSP NetSP = 9 [default = TELECOM];
inline bool DeviceDataType::has_netsp() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void DeviceDataType::set_has_netsp() {
  _has_bits_[0] |= 0x00000100u;
}
inline void DeviceDataType::clear_has_netsp() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void DeviceDataType::clear_netsp() {
  netsp_ = 1;
  clear_has_netsp();
}
inline ::cs::NetWorkSP DeviceDataType::netsp() const {
  return static_cast< ::cs::NetWorkSP >(netsp_);
}
inline void DeviceDataType::set_netsp(::cs::NetWorkSP value) {
  assert(::cs::NetWorkSP_IsValid(value));
  set_has_netsp();
  netsp_ = value;
}

// -------------------------------------------------------------------

// CSLoginReq

// required string PlayerAccount = 1;
inline bool CSLoginReq::has_playeraccount() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSLoginReq::set_has_playeraccount() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSLoginReq::clear_has_playeraccount() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSLoginReq::clear_playeraccount() {
  if (playeraccount_ != &::google::protobuf::internal::kEmptyString) {
    playeraccount_->clear();
  }
  clear_has_playeraccount();
}
inline const ::std::string& CSLoginReq::playeraccount() const {
  return *playeraccount_;
}
inline void CSLoginReq::set_playeraccount(const ::std::string& value) {
  set_has_playeraccount();
  if (playeraccount_ == &::google::protobuf::internal::kEmptyString) {
    playeraccount_ = new ::std::string;
  }
  playeraccount_->assign(value);
}
inline void CSLoginReq::set_playeraccount(const char* value) {
  set_has_playeraccount();
  if (playeraccount_ == &::google::protobuf::internal::kEmptyString) {
    playeraccount_ = new ::std::string;
  }
  playeraccount_->assign(value);
}
inline void CSLoginReq::set_playeraccount(const char* value, size_t size) {
  set_has_playeraccount();
  if (playeraccount_ == &::google::protobuf::internal::kEmptyString) {
    playeraccount_ = new ::std::string;
  }
  playeraccount_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CSLoginReq::mutable_playeraccount() {
  set_has_playeraccount();
  if (playeraccount_ == &::google::protobuf::internal::kEmptyString) {
    playeraccount_ = new ::std::string;
  }
  return playeraccount_;
}
inline ::std::string* CSLoginReq::release_playeraccount() {
  clear_has_playeraccount();
  if (playeraccount_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = playeraccount_;
    playeraccount_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CSLoginReq::set_allocated_playeraccount(::std::string* playeraccount) {
  if (playeraccount_ != &::google::protobuf::internal::kEmptyString) {
    delete playeraccount_;
  }
  if (playeraccount) {
    set_has_playeraccount();
    playeraccount_ = playeraccount;
  } else {
    clear_has_playeraccount();
    playeraccount_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string Token = 2;
inline bool CSLoginReq::has_token() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSLoginReq::set_has_token() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSLoginReq::clear_has_token() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSLoginReq::clear_token() {
  if (token_ != &::google::protobuf::internal::kEmptyString) {
    token_->clear();
  }
  clear_has_token();
}
inline const ::std::string& CSLoginReq::token() const {
  return *token_;
}
inline void CSLoginReq::set_token(const ::std::string& value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(value);
}
inline void CSLoginReq::set_token(const char* value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(value);
}
inline void CSLoginReq::set_token(const char* value, size_t size) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CSLoginReq::mutable_token() {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  return token_;
}
inline ::std::string* CSLoginReq::release_token() {
  clear_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = token_;
    token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CSLoginReq::set_allocated_token(::std::string* token) {
  if (token_ != &::google::protobuf::internal::kEmptyString) {
    delete token_;
  }
  if (token) {
    set_has_token();
    token_ = token;
  } else {
    clear_has_token();
    token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required .cs.VersionResourceType VersionResource = 3;
inline bool CSLoginReq::has_versionresource() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CSLoginReq::set_has_versionresource() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CSLoginReq::clear_has_versionresource() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CSLoginReq::clear_versionresource() {
  if (versionresource_ != NULL) versionresource_->::cs::VersionResourceType::Clear();
  clear_has_versionresource();
}
inline const ::cs::VersionResourceType& CSLoginReq::versionresource() const {
  return versionresource_ != NULL ? *versionresource_ : *default_instance_->versionresource_;
}
inline ::cs::VersionResourceType* CSLoginReq::mutable_versionresource() {
  set_has_versionresource();
  if (versionresource_ == NULL) versionresource_ = new ::cs::VersionResourceType;
  return versionresource_;
}
inline ::cs::VersionResourceType* CSLoginReq::release_versionresource() {
  clear_has_versionresource();
  ::cs::VersionResourceType* temp = versionresource_;
  versionresource_ = NULL;
  return temp;
}
inline void CSLoginReq::set_allocated_versionresource(::cs::VersionResourceType* versionresource) {
  delete versionresource_;
  versionresource_ = versionresource;
  if (versionresource) {
    set_has_versionresource();
  } else {
    clear_has_versionresource();
  }
}

// optional string PlatType = 4;
inline bool CSLoginReq::has_plattype() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CSLoginReq::set_has_plattype() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CSLoginReq::clear_has_plattype() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CSLoginReq::clear_plattype() {
  if (plattype_ != &::google::protobuf::internal::kEmptyString) {
    plattype_->clear();
  }
  clear_has_plattype();
}
inline const ::std::string& CSLoginReq::plattype() const {
  return *plattype_;
}
inline void CSLoginReq::set_plattype(const ::std::string& value) {
  set_has_plattype();
  if (plattype_ == &::google::protobuf::internal::kEmptyString) {
    plattype_ = new ::std::string;
  }
  plattype_->assign(value);
}
inline void CSLoginReq::set_plattype(const char* value) {
  set_has_plattype();
  if (plattype_ == &::google::protobuf::internal::kEmptyString) {
    plattype_ = new ::std::string;
  }
  plattype_->assign(value);
}
inline void CSLoginReq::set_plattype(const char* value, size_t size) {
  set_has_plattype();
  if (plattype_ == &::google::protobuf::internal::kEmptyString) {
    plattype_ = new ::std::string;
  }
  plattype_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CSLoginReq::mutable_plattype() {
  set_has_plattype();
  if (plattype_ == &::google::protobuf::internal::kEmptyString) {
    plattype_ = new ::std::string;
  }
  return plattype_;
}
inline ::std::string* CSLoginReq::release_plattype() {
  clear_has_plattype();
  if (plattype_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = plattype_;
    plattype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CSLoginReq::set_allocated_plattype(::std::string* plattype) {
  if (plattype_ != &::google::protobuf::internal::kEmptyString) {
    delete plattype_;
  }
  if (plattype) {
    set_has_plattype();
    plattype_ = plattype;
  } else {
    clear_has_plattype();
    plattype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .cs.DeviceDataType DeviceData = 5;
inline bool CSLoginReq::has_devicedata() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CSLoginReq::set_has_devicedata() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CSLoginReq::clear_has_devicedata() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CSLoginReq::clear_devicedata() {
  if (devicedata_ != NULL) devicedata_->::cs::DeviceDataType::Clear();
  clear_has_devicedata();
}
inline const ::cs::DeviceDataType& CSLoginReq::devicedata() const {
  return devicedata_ != NULL ? *devicedata_ : *default_instance_->devicedata_;
}
inline ::cs::DeviceDataType* CSLoginReq::mutable_devicedata() {
  set_has_devicedata();
  if (devicedata_ == NULL) devicedata_ = new ::cs::DeviceDataType;
  return devicedata_;
}
inline ::cs::DeviceDataType* CSLoginReq::release_devicedata() {
  clear_has_devicedata();
  ::cs::DeviceDataType* temp = devicedata_;
  devicedata_ = NULL;
  return temp;
}
inline void CSLoginReq::set_allocated_devicedata(::cs::DeviceDataType* devicedata) {
  delete devicedata_;
  devicedata_ = devicedata;
  if (devicedata) {
    set_has_devicedata();
  } else {
    clear_has_devicedata();
  }
}

// optional string PlayerPassWd = 6;
inline bool CSLoginReq::has_playerpasswd() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CSLoginReq::set_has_playerpasswd() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CSLoginReq::clear_has_playerpasswd() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CSLoginReq::clear_playerpasswd() {
  if (playerpasswd_ != &::google::protobuf::internal::kEmptyString) {
    playerpasswd_->clear();
  }
  clear_has_playerpasswd();
}
inline const ::std::string& CSLoginReq::playerpasswd() const {
  return *playerpasswd_;
}
inline void CSLoginReq::set_playerpasswd(const ::std::string& value) {
  set_has_playerpasswd();
  if (playerpasswd_ == &::google::protobuf::internal::kEmptyString) {
    playerpasswd_ = new ::std::string;
  }
  playerpasswd_->assign(value);
}
inline void CSLoginReq::set_playerpasswd(const char* value) {
  set_has_playerpasswd();
  if (playerpasswd_ == &::google::protobuf::internal::kEmptyString) {
    playerpasswd_ = new ::std::string;
  }
  playerpasswd_->assign(value);
}
inline void CSLoginReq::set_playerpasswd(const char* value, size_t size) {
  set_has_playerpasswd();
  if (playerpasswd_ == &::google::protobuf::internal::kEmptyString) {
    playerpasswd_ = new ::std::string;
  }
  playerpasswd_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CSLoginReq::mutable_playerpasswd() {
  set_has_playerpasswd();
  if (playerpasswd_ == &::google::protobuf::internal::kEmptyString) {
    playerpasswd_ = new ::std::string;
  }
  return playerpasswd_;
}
inline ::std::string* CSLoginReq::release_playerpasswd() {
  clear_has_playerpasswd();
  if (playerpasswd_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = playerpasswd_;
    playerpasswd_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CSLoginReq::set_allocated_playerpasswd(::std::string* playerpasswd) {
  if (playerpasswd_ != &::google::protobuf::internal::kEmptyString) {
    delete playerpasswd_;
  }
  if (playerpasswd) {
    set_has_playerpasswd();
    playerpasswd_ = playerpasswd;
  } else {
    clear_has_playerpasswd();
    playerpasswd_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// CSLoginRes

// optional int32 ServerTime = 1;
inline bool CSLoginRes::has_servertime() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSLoginRes::set_has_servertime() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSLoginRes::clear_has_servertime() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSLoginRes::clear_servertime() {
  servertime_ = 0;
  clear_has_servertime();
}
inline ::google::protobuf::int32 CSLoginRes::servertime() const {
  return servertime_;
}
inline void CSLoginRes::set_servertime(::google::protobuf::int32 value) {
  set_has_servertime();
  servertime_ = value;
}

// optional bool ForceUpdate = 2;
inline bool CSLoginRes::has_forceupdate() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSLoginRes::set_has_forceupdate() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSLoginRes::clear_has_forceupdate() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSLoginRes::clear_forceupdate() {
  forceupdate_ = false;
  clear_has_forceupdate();
}
inline bool CSLoginRes::forceupdate() const {
  return forceupdate_;
}
inline void CSLoginRes::set_forceupdate(bool value) {
  set_has_forceupdate();
  forceupdate_ = value;
}

// optional string DownLoadUrl = 3;
inline bool CSLoginRes::has_downloadurl() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CSLoginRes::set_has_downloadurl() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CSLoginRes::clear_has_downloadurl() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CSLoginRes::clear_downloadurl() {
  if (downloadurl_ != &::google::protobuf::internal::kEmptyString) {
    downloadurl_->clear();
  }
  clear_has_downloadurl();
}
inline const ::std::string& CSLoginRes::downloadurl() const {
  return *downloadurl_;
}
inline void CSLoginRes::set_downloadurl(const ::std::string& value) {
  set_has_downloadurl();
  if (downloadurl_ == &::google::protobuf::internal::kEmptyString) {
    downloadurl_ = new ::std::string;
  }
  downloadurl_->assign(value);
}
inline void CSLoginRes::set_downloadurl(const char* value) {
  set_has_downloadurl();
  if (downloadurl_ == &::google::protobuf::internal::kEmptyString) {
    downloadurl_ = new ::std::string;
  }
  downloadurl_->assign(value);
}
inline void CSLoginRes::set_downloadurl(const char* value, size_t size) {
  set_has_downloadurl();
  if (downloadurl_ == &::google::protobuf::internal::kEmptyString) {
    downloadurl_ = new ::std::string;
  }
  downloadurl_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CSLoginRes::mutable_downloadurl() {
  set_has_downloadurl();
  if (downloadurl_ == &::google::protobuf::internal::kEmptyString) {
    downloadurl_ = new ::std::string;
  }
  return downloadurl_;
}
inline ::std::string* CSLoginRes::release_downloadurl() {
  clear_has_downloadurl();
  if (downloadurl_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = downloadurl_;
    downloadurl_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CSLoginRes::set_allocated_downloadurl(::std::string* downloadurl) {
  if (downloadurl_ != &::google::protobuf::internal::kEmptyString) {
    delete downloadurl_;
  }
  if (downloadurl) {
    set_has_downloadurl();
    downloadurl_ = downloadurl;
  } else {
    clear_has_downloadurl();
    downloadurl_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 PlayerId = 4;
inline bool CSLoginRes::has_playerid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CSLoginRes::set_has_playerid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CSLoginRes::clear_has_playerid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CSLoginRes::clear_playerid() {
  playerid_ = 0;
  clear_has_playerid();
}
inline ::google::protobuf::int32 CSLoginRes::playerid() const {
  return playerid_;
}
inline void CSLoginRes::set_playerid(::google::protobuf::int32 value) {
  set_has_playerid();
  playerid_ = value;
}

// optional string Name = 5;
inline bool CSLoginRes::has_name() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CSLoginRes::set_has_name() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CSLoginRes::clear_has_name() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CSLoginRes::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& CSLoginRes::name() const {
  return *name_;
}
inline void CSLoginRes::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void CSLoginRes::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void CSLoginRes::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CSLoginRes::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* CSLoginRes::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CSLoginRes::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 RoleState = 6;
inline bool CSLoginRes::has_rolestate() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CSLoginRes::set_has_rolestate() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CSLoginRes::clear_has_rolestate() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CSLoginRes::clear_rolestate() {
  rolestate_ = 0;
  clear_has_rolestate();
}
inline ::google::protobuf::int32 CSLoginRes::rolestate() const {
  return rolestate_;
}
inline void CSLoginRes::set_rolestate(::google::protobuf::int32 value) {
  set_has_rolestate();
  rolestate_ = value;
}

// optional string Hash = 7;
inline bool CSLoginRes::has_hash() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CSLoginRes::set_has_hash() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CSLoginRes::clear_has_hash() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CSLoginRes::clear_hash() {
  if (hash_ != &::google::protobuf::internal::kEmptyString) {
    hash_->clear();
  }
  clear_has_hash();
}
inline const ::std::string& CSLoginRes::hash() const {
  return *hash_;
}
inline void CSLoginRes::set_hash(const ::std::string& value) {
  set_has_hash();
  if (hash_ == &::google::protobuf::internal::kEmptyString) {
    hash_ = new ::std::string;
  }
  hash_->assign(value);
}
inline void CSLoginRes::set_hash(const char* value) {
  set_has_hash();
  if (hash_ == &::google::protobuf::internal::kEmptyString) {
    hash_ = new ::std::string;
  }
  hash_->assign(value);
}
inline void CSLoginRes::set_hash(const char* value, size_t size) {
  set_has_hash();
  if (hash_ == &::google::protobuf::internal::kEmptyString) {
    hash_ = new ::std::string;
  }
  hash_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CSLoginRes::mutable_hash() {
  set_has_hash();
  if (hash_ == &::google::protobuf::internal::kEmptyString) {
    hash_ = new ::std::string;
  }
  return hash_;
}
inline ::std::string* CSLoginRes::release_hash() {
  clear_has_hash();
  if (hash_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = hash_;
    hash_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CSLoginRes::set_allocated_hash(::std::string* hash) {
  if (hash_ != &::google::protobuf::internal::kEmptyString) {
    delete hash_;
  }
  if (hash) {
    set_has_hash();
    hash_ = hash;
  } else {
    clear_has_hash();
    hash_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes SecretKey = 8;
inline bool CSLoginRes::has_secretkey() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void CSLoginRes::set_has_secretkey() {
  _has_bits_[0] |= 0x00000080u;
}
inline void CSLoginRes::clear_has_secretkey() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void CSLoginRes::clear_secretkey() {
  if (secretkey_ != &::google::protobuf::internal::kEmptyString) {
    secretkey_->clear();
  }
  clear_has_secretkey();
}
inline const ::std::string& CSLoginRes::secretkey() const {
  return *secretkey_;
}
inline void CSLoginRes::set_secretkey(const ::std::string& value) {
  set_has_secretkey();
  if (secretkey_ == &::google::protobuf::internal::kEmptyString) {
    secretkey_ = new ::std::string;
  }
  secretkey_->assign(value);
}
inline void CSLoginRes::set_secretkey(const char* value) {
  set_has_secretkey();
  if (secretkey_ == &::google::protobuf::internal::kEmptyString) {
    secretkey_ = new ::std::string;
  }
  secretkey_->assign(value);
}
inline void CSLoginRes::set_secretkey(const void* value, size_t size) {
  set_has_secretkey();
  if (secretkey_ == &::google::protobuf::internal::kEmptyString) {
    secretkey_ = new ::std::string;
  }
  secretkey_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CSLoginRes::mutable_secretkey() {
  set_has_secretkey();
  if (secretkey_ == &::google::protobuf::internal::kEmptyString) {
    secretkey_ = new ::std::string;
  }
  return secretkey_;
}
inline ::std::string* CSLoginRes::release_secretkey() {
  clear_has_secretkey();
  if (secretkey_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = secretkey_;
    secretkey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CSLoginRes::set_allocated_secretkey(::std::string* secretkey) {
  if (secretkey_ != &::google::protobuf::internal::kEmptyString) {
    delete secretkey_;
  }
  if (secretkey) {
    set_has_secretkey();
    secretkey_ = secretkey;
  } else {
    clear_has_secretkey();
    secretkey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool IsBeAttacking = 9;
inline bool CSLoginRes::has_isbeattacking() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void CSLoginRes::set_has_isbeattacking() {
  _has_bits_[0] |= 0x00000100u;
}
inline void CSLoginRes::clear_has_isbeattacking() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void CSLoginRes::clear_isbeattacking() {
  isbeattacking_ = false;
  clear_has_isbeattacking();
}
inline bool CSLoginRes::isbeattacking() const {
  return isbeattacking_;
}
inline void CSLoginRes::set_isbeattacking(bool value) {
  set_has_isbeattacking();
  isbeattacking_ = value;
}

// optional uint32 BeAttackingLeftTime = 10;
inline bool CSLoginRes::has_beattackinglefttime() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void CSLoginRes::set_has_beattackinglefttime() {
  _has_bits_[0] |= 0x00000200u;
}
inline void CSLoginRes::clear_has_beattackinglefttime() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void CSLoginRes::clear_beattackinglefttime() {
  beattackinglefttime_ = 0u;
  clear_has_beattackinglefttime();
}
inline ::google::protobuf::uint32 CSLoginRes::beattackinglefttime() const {
  return beattackinglefttime_;
}
inline void CSLoginRes::set_beattackinglefttime(::google::protobuf::uint32 value) {
  set_has_beattackinglefttime();
  beattackinglefttime_ = value;
}

// optional uint64 Env = 11;
inline bool CSLoginRes::has_env() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void CSLoginRes::set_has_env() {
  _has_bits_[0] |= 0x00000400u;
}
inline void CSLoginRes::clear_has_env() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void CSLoginRes::clear_env() {
  env_ = GOOGLE_ULONGLONG(0);
  clear_has_env();
}
inline ::google::protobuf::uint64 CSLoginRes::env() const {
  return env_;
}
inline void CSLoginRes::set_env(::google::protobuf::uint64 value) {
  set_has_env();
  env_ = value;
}

// optional string Notify = 12;
inline bool CSLoginRes::has_notify() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void CSLoginRes::set_has_notify() {
  _has_bits_[0] |= 0x00000800u;
}
inline void CSLoginRes::clear_has_notify() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void CSLoginRes::clear_notify() {
  if (notify_ != &::google::protobuf::internal::kEmptyString) {
    notify_->clear();
  }
  clear_has_notify();
}
inline const ::std::string& CSLoginRes::notify() const {
  return *notify_;
}
inline void CSLoginRes::set_notify(const ::std::string& value) {
  set_has_notify();
  if (notify_ == &::google::protobuf::internal::kEmptyString) {
    notify_ = new ::std::string;
  }
  notify_->assign(value);
}
inline void CSLoginRes::set_notify(const char* value) {
  set_has_notify();
  if (notify_ == &::google::protobuf::internal::kEmptyString) {
    notify_ = new ::std::string;
  }
  notify_->assign(value);
}
inline void CSLoginRes::set_notify(const char* value, size_t size) {
  set_has_notify();
  if (notify_ == &::google::protobuf::internal::kEmptyString) {
    notify_ = new ::std::string;
  }
  notify_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CSLoginRes::mutable_notify() {
  set_has_notify();
  if (notify_ == &::google::protobuf::internal::kEmptyString) {
    notify_ = new ::std::string;
  }
  return notify_;
}
inline ::std::string* CSLoginRes::release_notify() {
  clear_has_notify();
  if (notify_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = notify_;
    notify_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CSLoginRes::set_allocated_notify(::std::string* notify) {
  if (notify_ != &::google::protobuf::internal::kEmptyString) {
    delete notify_;
  }
  if (notify) {
    set_has_notify();
    notify_ = notify;
  } else {
    clear_has_notify();
    notify_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 DefenceAeaId = 13;
inline bool CSLoginRes::has_defenceaeaid() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void CSLoginRes::set_has_defenceaeaid() {
  _has_bits_[0] |= 0x00001000u;
}
inline void CSLoginRes::clear_has_defenceaeaid() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void CSLoginRes::clear_defenceaeaid() {
  defenceaeaid_ = 0;
  clear_has_defenceaeaid();
}
inline ::google::protobuf::int32 CSLoginRes::defenceaeaid() const {
  return defenceaeaid_;
}
inline void CSLoginRes::set_defenceaeaid(::google::protobuf::int32 value) {
  set_has_defenceaeaid();
  defenceaeaid_ = value;
}

// -------------------------------------------------------------------

// CSReloginReq

// required string PlayerAccount = 1;
inline bool CSReloginReq::has_playeraccount() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSReloginReq::set_has_playeraccount() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSReloginReq::clear_has_playeraccount() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSReloginReq::clear_playeraccount() {
  if (playeraccount_ != &::google::protobuf::internal::kEmptyString) {
    playeraccount_->clear();
  }
  clear_has_playeraccount();
}
inline const ::std::string& CSReloginReq::playeraccount() const {
  return *playeraccount_;
}
inline void CSReloginReq::set_playeraccount(const ::std::string& value) {
  set_has_playeraccount();
  if (playeraccount_ == &::google::protobuf::internal::kEmptyString) {
    playeraccount_ = new ::std::string;
  }
  playeraccount_->assign(value);
}
inline void CSReloginReq::set_playeraccount(const char* value) {
  set_has_playeraccount();
  if (playeraccount_ == &::google::protobuf::internal::kEmptyString) {
    playeraccount_ = new ::std::string;
  }
  playeraccount_->assign(value);
}
inline void CSReloginReq::set_playeraccount(const char* value, size_t size) {
  set_has_playeraccount();
  if (playeraccount_ == &::google::protobuf::internal::kEmptyString) {
    playeraccount_ = new ::std::string;
  }
  playeraccount_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CSReloginReq::mutable_playeraccount() {
  set_has_playeraccount();
  if (playeraccount_ == &::google::protobuf::internal::kEmptyString) {
    playeraccount_ = new ::std::string;
  }
  return playeraccount_;
}
inline ::std::string* CSReloginReq::release_playeraccount() {
  clear_has_playeraccount();
  if (playeraccount_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = playeraccount_;
    playeraccount_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CSReloginReq::set_allocated_playeraccount(::std::string* playeraccount) {
  if (playeraccount_ != &::google::protobuf::internal::kEmptyString) {
    delete playeraccount_;
  }
  if (playeraccount) {
    set_has_playeraccount();
    playeraccount_ = playeraccount;
  } else {
    clear_has_playeraccount();
    playeraccount_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string Token = 2;
inline bool CSReloginReq::has_token() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSReloginReq::set_has_token() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSReloginReq::clear_has_token() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSReloginReq::clear_token() {
  if (token_ != &::google::protobuf::internal::kEmptyString) {
    token_->clear();
  }
  clear_has_token();
}
inline const ::std::string& CSReloginReq::token() const {
  return *token_;
}
inline void CSReloginReq::set_token(const ::std::string& value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(value);
}
inline void CSReloginReq::set_token(const char* value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(value);
}
inline void CSReloginReq::set_token(const char* value, size_t size) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CSReloginReq::mutable_token() {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  return token_;
}
inline ::std::string* CSReloginReq::release_token() {
  clear_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = token_;
    token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CSReloginReq::set_allocated_token(::std::string* token) {
  if (token_ != &::google::protobuf::internal::kEmptyString) {
    delete token_;
  }
  if (token) {
    set_has_token();
    token_ = token;
  } else {
    clear_has_token();
    token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required .cs.VersionResourceType VersionResource = 3;
inline bool CSReloginReq::has_versionresource() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CSReloginReq::set_has_versionresource() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CSReloginReq::clear_has_versionresource() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CSReloginReq::clear_versionresource() {
  if (versionresource_ != NULL) versionresource_->::cs::VersionResourceType::Clear();
  clear_has_versionresource();
}
inline const ::cs::VersionResourceType& CSReloginReq::versionresource() const {
  return versionresource_ != NULL ? *versionresource_ : *default_instance_->versionresource_;
}
inline ::cs::VersionResourceType* CSReloginReq::mutable_versionresource() {
  set_has_versionresource();
  if (versionresource_ == NULL) versionresource_ = new ::cs::VersionResourceType;
  return versionresource_;
}
inline ::cs::VersionResourceType* CSReloginReq::release_versionresource() {
  clear_has_versionresource();
  ::cs::VersionResourceType* temp = versionresource_;
  versionresource_ = NULL;
  return temp;
}
inline void CSReloginReq::set_allocated_versionresource(::cs::VersionResourceType* versionresource) {
  delete versionresource_;
  versionresource_ = versionresource;
  if (versionresource) {
    set_has_versionresource();
  } else {
    clear_has_versionresource();
  }
}

// optional string PlatType = 4;
inline bool CSReloginReq::has_plattype() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CSReloginReq::set_has_plattype() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CSReloginReq::clear_has_plattype() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CSReloginReq::clear_plattype() {
  if (plattype_ != &::google::protobuf::internal::kEmptyString) {
    plattype_->clear();
  }
  clear_has_plattype();
}
inline const ::std::string& CSReloginReq::plattype() const {
  return *plattype_;
}
inline void CSReloginReq::set_plattype(const ::std::string& value) {
  set_has_plattype();
  if (plattype_ == &::google::protobuf::internal::kEmptyString) {
    plattype_ = new ::std::string;
  }
  plattype_->assign(value);
}
inline void CSReloginReq::set_plattype(const char* value) {
  set_has_plattype();
  if (plattype_ == &::google::protobuf::internal::kEmptyString) {
    plattype_ = new ::std::string;
  }
  plattype_->assign(value);
}
inline void CSReloginReq::set_plattype(const char* value, size_t size) {
  set_has_plattype();
  if (plattype_ == &::google::protobuf::internal::kEmptyString) {
    plattype_ = new ::std::string;
  }
  plattype_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CSReloginReq::mutable_plattype() {
  set_has_plattype();
  if (plattype_ == &::google::protobuf::internal::kEmptyString) {
    plattype_ = new ::std::string;
  }
  return plattype_;
}
inline ::std::string* CSReloginReq::release_plattype() {
  clear_has_plattype();
  if (plattype_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = plattype_;
    plattype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CSReloginReq::set_allocated_plattype(::std::string* plattype) {
  if (plattype_ != &::google::protobuf::internal::kEmptyString) {
    delete plattype_;
  }
  if (plattype) {
    set_has_plattype();
    plattype_ = plattype;
  } else {
    clear_has_plattype();
    plattype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .cs.DeviceDataType DeviceData = 5;
inline bool CSReloginReq::has_devicedata() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CSReloginReq::set_has_devicedata() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CSReloginReq::clear_has_devicedata() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CSReloginReq::clear_devicedata() {
  if (devicedata_ != NULL) devicedata_->::cs::DeviceDataType::Clear();
  clear_has_devicedata();
}
inline const ::cs::DeviceDataType& CSReloginReq::devicedata() const {
  return devicedata_ != NULL ? *devicedata_ : *default_instance_->devicedata_;
}
inline ::cs::DeviceDataType* CSReloginReq::mutable_devicedata() {
  set_has_devicedata();
  if (devicedata_ == NULL) devicedata_ = new ::cs::DeviceDataType;
  return devicedata_;
}
inline ::cs::DeviceDataType* CSReloginReq::release_devicedata() {
  clear_has_devicedata();
  ::cs::DeviceDataType* temp = devicedata_;
  devicedata_ = NULL;
  return temp;
}
inline void CSReloginReq::set_allocated_devicedata(::cs::DeviceDataType* devicedata) {
  delete devicedata_;
  devicedata_ = devicedata;
  if (devicedata) {
    set_has_devicedata();
  } else {
    clear_has_devicedata();
  }
}

// -------------------------------------------------------------------

// CSReloginRes

// optional int32 ServerTime = 1;
inline bool CSReloginRes::has_servertime() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSReloginRes::set_has_servertime() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSReloginRes::clear_has_servertime() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSReloginRes::clear_servertime() {
  servertime_ = 0;
  clear_has_servertime();
}
inline ::google::protobuf::int32 CSReloginRes::servertime() const {
  return servertime_;
}
inline void CSReloginRes::set_servertime(::google::protobuf::int32 value) {
  set_has_servertime();
  servertime_ = value;
}

// optional bool ForceUpdate = 2;
inline bool CSReloginRes::has_forceupdate() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSReloginRes::set_has_forceupdate() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSReloginRes::clear_has_forceupdate() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSReloginRes::clear_forceupdate() {
  forceupdate_ = false;
  clear_has_forceupdate();
}
inline bool CSReloginRes::forceupdate() const {
  return forceupdate_;
}
inline void CSReloginRes::set_forceupdate(bool value) {
  set_has_forceupdate();
  forceupdate_ = value;
}

// optional string DownLoadUrl = 3;
inline bool CSReloginRes::has_downloadurl() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CSReloginRes::set_has_downloadurl() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CSReloginRes::clear_has_downloadurl() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CSReloginRes::clear_downloadurl() {
  if (downloadurl_ != &::google::protobuf::internal::kEmptyString) {
    downloadurl_->clear();
  }
  clear_has_downloadurl();
}
inline const ::std::string& CSReloginRes::downloadurl() const {
  return *downloadurl_;
}
inline void CSReloginRes::set_downloadurl(const ::std::string& value) {
  set_has_downloadurl();
  if (downloadurl_ == &::google::protobuf::internal::kEmptyString) {
    downloadurl_ = new ::std::string;
  }
  downloadurl_->assign(value);
}
inline void CSReloginRes::set_downloadurl(const char* value) {
  set_has_downloadurl();
  if (downloadurl_ == &::google::protobuf::internal::kEmptyString) {
    downloadurl_ = new ::std::string;
  }
  downloadurl_->assign(value);
}
inline void CSReloginRes::set_downloadurl(const char* value, size_t size) {
  set_has_downloadurl();
  if (downloadurl_ == &::google::protobuf::internal::kEmptyString) {
    downloadurl_ = new ::std::string;
  }
  downloadurl_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CSReloginRes::mutable_downloadurl() {
  set_has_downloadurl();
  if (downloadurl_ == &::google::protobuf::internal::kEmptyString) {
    downloadurl_ = new ::std::string;
  }
  return downloadurl_;
}
inline ::std::string* CSReloginRes::release_downloadurl() {
  clear_has_downloadurl();
  if (downloadurl_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = downloadurl_;
    downloadurl_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CSReloginRes::set_allocated_downloadurl(::std::string* downloadurl) {
  if (downloadurl_ != &::google::protobuf::internal::kEmptyString) {
    delete downloadurl_;
  }
  if (downloadurl) {
    set_has_downloadurl();
    downloadurl_ = downloadurl;
  } else {
    clear_has_downloadurl();
    downloadurl_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 PlayerId = 4;
inline bool CSReloginRes::has_playerid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CSReloginRes::set_has_playerid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CSReloginRes::clear_has_playerid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CSReloginRes::clear_playerid() {
  playerid_ = 0;
  clear_has_playerid();
}
inline ::google::protobuf::int32 CSReloginRes::playerid() const {
  return playerid_;
}
inline void CSReloginRes::set_playerid(::google::protobuf::int32 value) {
  set_has_playerid();
  playerid_ = value;
}

// optional string Name = 5;
inline bool CSReloginRes::has_name() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CSReloginRes::set_has_name() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CSReloginRes::clear_has_name() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CSReloginRes::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& CSReloginRes::name() const {
  return *name_;
}
inline void CSReloginRes::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void CSReloginRes::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void CSReloginRes::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CSReloginRes::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* CSReloginRes::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CSReloginRes::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 RoleState = 6;
inline bool CSReloginRes::has_rolestate() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CSReloginRes::set_has_rolestate() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CSReloginRes::clear_has_rolestate() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CSReloginRes::clear_rolestate() {
  rolestate_ = 0;
  clear_has_rolestate();
}
inline ::google::protobuf::int32 CSReloginRes::rolestate() const {
  return rolestate_;
}
inline void CSReloginRes::set_rolestate(::google::protobuf::int32 value) {
  set_has_rolestate();
  rolestate_ = value;
}

// optional string Hash = 7;
inline bool CSReloginRes::has_hash() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CSReloginRes::set_has_hash() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CSReloginRes::clear_has_hash() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CSReloginRes::clear_hash() {
  if (hash_ != &::google::protobuf::internal::kEmptyString) {
    hash_->clear();
  }
  clear_has_hash();
}
inline const ::std::string& CSReloginRes::hash() const {
  return *hash_;
}
inline void CSReloginRes::set_hash(const ::std::string& value) {
  set_has_hash();
  if (hash_ == &::google::protobuf::internal::kEmptyString) {
    hash_ = new ::std::string;
  }
  hash_->assign(value);
}
inline void CSReloginRes::set_hash(const char* value) {
  set_has_hash();
  if (hash_ == &::google::protobuf::internal::kEmptyString) {
    hash_ = new ::std::string;
  }
  hash_->assign(value);
}
inline void CSReloginRes::set_hash(const char* value, size_t size) {
  set_has_hash();
  if (hash_ == &::google::protobuf::internal::kEmptyString) {
    hash_ = new ::std::string;
  }
  hash_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CSReloginRes::mutable_hash() {
  set_has_hash();
  if (hash_ == &::google::protobuf::internal::kEmptyString) {
    hash_ = new ::std::string;
  }
  return hash_;
}
inline ::std::string* CSReloginRes::release_hash() {
  clear_has_hash();
  if (hash_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = hash_;
    hash_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CSReloginRes::set_allocated_hash(::std::string* hash) {
  if (hash_ != &::google::protobuf::internal::kEmptyString) {
    delete hash_;
  }
  if (hash) {
    set_has_hash();
    hash_ = hash;
  } else {
    clear_has_hash();
    hash_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes SecretKey = 8;
inline bool CSReloginRes::has_secretkey() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void CSReloginRes::set_has_secretkey() {
  _has_bits_[0] |= 0x00000080u;
}
inline void CSReloginRes::clear_has_secretkey() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void CSReloginRes::clear_secretkey() {
  if (secretkey_ != &::google::protobuf::internal::kEmptyString) {
    secretkey_->clear();
  }
  clear_has_secretkey();
}
inline const ::std::string& CSReloginRes::secretkey() const {
  return *secretkey_;
}
inline void CSReloginRes::set_secretkey(const ::std::string& value) {
  set_has_secretkey();
  if (secretkey_ == &::google::protobuf::internal::kEmptyString) {
    secretkey_ = new ::std::string;
  }
  secretkey_->assign(value);
}
inline void CSReloginRes::set_secretkey(const char* value) {
  set_has_secretkey();
  if (secretkey_ == &::google::protobuf::internal::kEmptyString) {
    secretkey_ = new ::std::string;
  }
  secretkey_->assign(value);
}
inline void CSReloginRes::set_secretkey(const void* value, size_t size) {
  set_has_secretkey();
  if (secretkey_ == &::google::protobuf::internal::kEmptyString) {
    secretkey_ = new ::std::string;
  }
  secretkey_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CSReloginRes::mutable_secretkey() {
  set_has_secretkey();
  if (secretkey_ == &::google::protobuf::internal::kEmptyString) {
    secretkey_ = new ::std::string;
  }
  return secretkey_;
}
inline ::std::string* CSReloginRes::release_secretkey() {
  clear_has_secretkey();
  if (secretkey_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = secretkey_;
    secretkey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CSReloginRes::set_allocated_secretkey(::std::string* secretkey) {
  if (secretkey_ != &::google::protobuf::internal::kEmptyString) {
    delete secretkey_;
  }
  if (secretkey) {
    set_has_secretkey();
    secretkey_ = secretkey;
  } else {
    clear_has_secretkey();
    secretkey_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool IsBeAttacking = 9;
inline bool CSReloginRes::has_isbeattacking() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void CSReloginRes::set_has_isbeattacking() {
  _has_bits_[0] |= 0x00000100u;
}
inline void CSReloginRes::clear_has_isbeattacking() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void CSReloginRes::clear_isbeattacking() {
  isbeattacking_ = false;
  clear_has_isbeattacking();
}
inline bool CSReloginRes::isbeattacking() const {
  return isbeattacking_;
}
inline void CSReloginRes::set_isbeattacking(bool value) {
  set_has_isbeattacking();
  isbeattacking_ = value;
}

// optional uint32 BeAttackingLeftTime = 10;
inline bool CSReloginRes::has_beattackinglefttime() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void CSReloginRes::set_has_beattackinglefttime() {
  _has_bits_[0] |= 0x00000200u;
}
inline void CSReloginRes::clear_has_beattackinglefttime() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void CSReloginRes::clear_beattackinglefttime() {
  beattackinglefttime_ = 0u;
  clear_has_beattackinglefttime();
}
inline ::google::protobuf::uint32 CSReloginRes::beattackinglefttime() const {
  return beattackinglefttime_;
}
inline void CSReloginRes::set_beattackinglefttime(::google::protobuf::uint32 value) {
  set_has_beattackinglefttime();
  beattackinglefttime_ = value;
}

// -------------------------------------------------------------------

// CSFinalizeaccountReq

// required int32 FinalColor = 1;
inline bool CSFinalizeaccountReq::has_finalcolor() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSFinalizeaccountReq::set_has_finalcolor() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSFinalizeaccountReq::clear_has_finalcolor() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSFinalizeaccountReq::clear_finalcolor() {
  finalcolor_ = 0;
  clear_has_finalcolor();
}
inline ::google::protobuf::int32 CSFinalizeaccountReq::finalcolor() const {
  return finalcolor_;
}
inline void CSFinalizeaccountReq::set_finalcolor(::google::protobuf::int32 value) {
  set_has_finalcolor();
  finalcolor_ = value;
}

// required string FinalName = 2;
inline bool CSFinalizeaccountReq::has_finalname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSFinalizeaccountReq::set_has_finalname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSFinalizeaccountReq::clear_has_finalname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSFinalizeaccountReq::clear_finalname() {
  if (finalname_ != &::google::protobuf::internal::kEmptyString) {
    finalname_->clear();
  }
  clear_has_finalname();
}
inline const ::std::string& CSFinalizeaccountReq::finalname() const {
  return *finalname_;
}
inline void CSFinalizeaccountReq::set_finalname(const ::std::string& value) {
  set_has_finalname();
  if (finalname_ == &::google::protobuf::internal::kEmptyString) {
    finalname_ = new ::std::string;
  }
  finalname_->assign(value);
}
inline void CSFinalizeaccountReq::set_finalname(const char* value) {
  set_has_finalname();
  if (finalname_ == &::google::protobuf::internal::kEmptyString) {
    finalname_ = new ::std::string;
  }
  finalname_->assign(value);
}
inline void CSFinalizeaccountReq::set_finalname(const char* value, size_t size) {
  set_has_finalname();
  if (finalname_ == &::google::protobuf::internal::kEmptyString) {
    finalname_ = new ::std::string;
  }
  finalname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CSFinalizeaccountReq::mutable_finalname() {
  set_has_finalname();
  if (finalname_ == &::google::protobuf::internal::kEmptyString) {
    finalname_ = new ::std::string;
  }
  return finalname_;
}
inline ::std::string* CSFinalizeaccountReq::release_finalname() {
  clear_has_finalname();
  if (finalname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = finalname_;
    finalname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CSFinalizeaccountReq::set_allocated_finalname(::std::string* finalname) {
  if (finalname_ != &::google::protobuf::internal::kEmptyString) {
    delete finalname_;
  }
  if (finalname) {
    set_has_finalname();
    finalname_ = finalname;
  } else {
    clear_has_finalname();
    finalname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// CSFinalizeaccountRes

// optional string Name = 1;
inline bool CSFinalizeaccountRes::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSFinalizeaccountRes::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSFinalizeaccountRes::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSFinalizeaccountRes::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& CSFinalizeaccountRes::name() const {
  return *name_;
}
inline void CSFinalizeaccountRes::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void CSFinalizeaccountRes::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void CSFinalizeaccountRes::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CSFinalizeaccountRes::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* CSFinalizeaccountRes::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CSFinalizeaccountRes::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 Status = 2;
inline bool CSFinalizeaccountRes::has_status() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSFinalizeaccountRes::set_has_status() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSFinalizeaccountRes::clear_has_status() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSFinalizeaccountRes::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::google::protobuf::int32 CSFinalizeaccountRes::status() const {
  return status_;
}
inline void CSFinalizeaccountRes::set_status(::google::protobuf::int32 value) {
  set_has_status();
  status_ = value;
}

// optional string Reason = 3;
inline bool CSFinalizeaccountRes::has_reason() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CSFinalizeaccountRes::set_has_reason() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CSFinalizeaccountRes::clear_has_reason() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CSFinalizeaccountRes::clear_reason() {
  if (reason_ != &::google::protobuf::internal::kEmptyString) {
    reason_->clear();
  }
  clear_has_reason();
}
inline const ::std::string& CSFinalizeaccountRes::reason() const {
  return *reason_;
}
inline void CSFinalizeaccountRes::set_reason(const ::std::string& value) {
  set_has_reason();
  if (reason_ == &::google::protobuf::internal::kEmptyString) {
    reason_ = new ::std::string;
  }
  reason_->assign(value);
}
inline void CSFinalizeaccountRes::set_reason(const char* value) {
  set_has_reason();
  if (reason_ == &::google::protobuf::internal::kEmptyString) {
    reason_ = new ::std::string;
  }
  reason_->assign(value);
}
inline void CSFinalizeaccountRes::set_reason(const char* value, size_t size) {
  set_has_reason();
  if (reason_ == &::google::protobuf::internal::kEmptyString) {
    reason_ = new ::std::string;
  }
  reason_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CSFinalizeaccountRes::mutable_reason() {
  set_has_reason();
  if (reason_ == &::google::protobuf::internal::kEmptyString) {
    reason_ = new ::std::string;
  }
  return reason_;
}
inline ::std::string* CSFinalizeaccountRes::release_reason() {
  clear_has_reason();
  if (reason_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = reason_;
    reason_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CSFinalizeaccountRes::set_allocated_reason(::std::string* reason) {
  if (reason_ != &::google::protobuf::internal::kEmptyString) {
    delete reason_;
  }
  if (reason) {
    set_has_reason();
    reason_ = reason;
  } else {
    clear_has_reason();
    reason_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// CSGetRandomNameReq

// -------------------------------------------------------------------

// CSGetRandomNameRes

// optional string Name = 1;
inline bool CSGetRandomNameRes::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSGetRandomNameRes::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSGetRandomNameRes::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSGetRandomNameRes::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& CSGetRandomNameRes::name() const {
  return *name_;
}
inline void CSGetRandomNameRes::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void CSGetRandomNameRes::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void CSGetRandomNameRes::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CSGetRandomNameRes::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* CSGetRandomNameRes::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CSGetRandomNameRes::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// CSChangeNameReq

// optional string NewName = 1;
inline bool CSChangeNameReq::has_newname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSChangeNameReq::set_has_newname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSChangeNameReq::clear_has_newname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSChangeNameReq::clear_newname() {
  if (newname_ != &::google::protobuf::internal::kEmptyString) {
    newname_->clear();
  }
  clear_has_newname();
}
inline const ::std::string& CSChangeNameReq::newname() const {
  return *newname_;
}
inline void CSChangeNameReq::set_newname(const ::std::string& value) {
  set_has_newname();
  if (newname_ == &::google::protobuf::internal::kEmptyString) {
    newname_ = new ::std::string;
  }
  newname_->assign(value);
}
inline void CSChangeNameReq::set_newname(const char* value) {
  set_has_newname();
  if (newname_ == &::google::protobuf::internal::kEmptyString) {
    newname_ = new ::std::string;
  }
  newname_->assign(value);
}
inline void CSChangeNameReq::set_newname(const char* value, size_t size) {
  set_has_newname();
  if (newname_ == &::google::protobuf::internal::kEmptyString) {
    newname_ = new ::std::string;
  }
  newname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CSChangeNameReq::mutable_newname() {
  set_has_newname();
  if (newname_ == &::google::protobuf::internal::kEmptyString) {
    newname_ = new ::std::string;
  }
  return newname_;
}
inline ::std::string* CSChangeNameReq::release_newname() {
  clear_has_newname();
  if (newname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = newname_;
    newname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CSChangeNameReq::set_allocated_newname(::std::string* newname) {
  if (newname_ != &::google::protobuf::internal::kEmptyString) {
    delete newname_;
  }
  if (newname) {
    set_has_newname();
    newname_ = newname;
  } else {
    clear_has_newname();
    newname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// CSChangeNameRes


// @@protoc_insertion_point(namespace_scope)

}  // namespace cs

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_cs_5flogin_2eproto__INCLUDED
